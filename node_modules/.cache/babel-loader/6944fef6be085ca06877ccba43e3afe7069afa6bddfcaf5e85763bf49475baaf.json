{"ast":null,"code":"/**\n * AlphaVantage takes in a query, determines the request type, determines the subRequestType, extracts\n * the necessary information, forms the apiParams, calls the api, and summarizes the apiCallData\n * @param query - the query that the user is asking\n */\n\nconst {\n  Configuration,\n  OpenAIApi\n} = require('openai');\n\n// to do: move these to env variables\n// 2. Make summary better\n\nconst orgId = \"org-rnY9Z2LuVmBnRlAsfLipqzcf\";\nconst apiKey = \"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\";\nconst configuration = new Configuration({\n  orgId: orgId,\n  apiKey: apiKey\n});\nconst openai = new OpenAIApi(configuration);\nexport async function AlphaVantage(query) {\n  async function workflow(query) {\n    console.log(\"AV-1: extracting requestType\");\n    const requestType = await getRequestType(query); // STEP 1\n    console.log(\"AV-3: extracting subRequestType from requestType:\", requestType, \"and query:\", query);\n    const subRequestType = await getSubRequestType(requestType, query); // STEP 3\n    console.log(\"AV: Step 4: extractingInfo from requestType & Query:\", requestType, query);\n    const extractedInfo = await extractInfo(requestType, query); // STEP 4\n    console.log(\"AV: Step 5: formingApiParams from extractedInfo and subRequestType:\", extractedInfo, subRequestType);\n    const apiParams = await formApiParams(subRequestType, extractedInfo); // STEP 5\n    console.log(\"AV: Making API Call with params:\", apiParams);\n    const apiCallData = await callApi(apiParams); // STEP 6\n    console.log(\"AV: Step 7: summarizingApiCallData with current date, requestType, subrequestType, apiCallData, and query:\", requestType, subRequestType, apiCallData, query);\n    const summarizedApiCallData = await summarizeApiCallData(requestType, subRequestType, apiCallData, query); // STEP 7\n    console.log(\"AV: Final Step: Return Summary\", summarizedApiCallData);\n    return summarizedApiCallData;\n  }\n  const response = await workflow(query);\n  return response;\n  // STEP 1\n  async function getRequestType(query) {\n    const response = await openai.createCompletion({\n      model: \"text-davinci-003\",\n      prompt: `\n\n           Your task is to classify a given query into one of the following four categories:\n\n            1. Core Stock APIS - Intraday, Daily, Weekly, Monthly, & Current Price (just stock prices)\n            2. Forex - Fiat Exchange Rates, Intraday, Daily, Weekly, Monthly (just exchange rates)\n            3. Cryptocurrency - Crypto Exchange Rates, Intraday, Daily, Weekly, Monthly (just exchange rates, but for crypto)\n            4. Technical Indicators - SMA, EMA, WMA, DEMA, TEMA, TRIMA, KAMA, MAMA, T3, MACD, MACDEXT, STOCH, STOCHF, RSI, STOCHRSI, WILLR, ADX, ADXR, APO, PPO, MOM, BOP, CCI, CMO, ROC, ROCR, AROON, AROONOSC, MFI, TRIX, ULTOSC, DX, MINUS_DI, PLUS_DI, MINUS_DM, PLUS_DM, BBANDS, MIDPOINT, MIDPRICE, SAR, TRANGE, ATR, NATR, AD, ADOSC, OBV, HT_TRENDLINE, HT_SINE, HT_TRENDMODE, HT_DCPERIOD, HT_DCPHASE, HT_PHASOR (technical indicators)\n\n            Your program should be able to determine the request type based on the given query and output only the number that is associated with the relevant category.\n\n            Here are some examples of the types of questions your program should be able to classify:\n\n            - What is the current price of $TSLA? (1)\n            - What are intraday prices for $TSLA? (1)\n            - What are daily prices for $TSLA? (1)\n            - What are weekly prices for $TSLA? (1)\n            - What are monthly prices for $TSLA? (1)\n            - What is the current exchange rate for $USD to $CAD? (2)\n            - What is the intraday exchange rate for $USD to $CAD? (2)\n            - What are daily exchange rates for $USD to $CAD? (2)\n            - What are weekly exchange rates for $USD to $CAD? (2)\n            - What are monthly exchange rates for $USD to $CAD? (2)\n            - What is the current exchange rate for $BTC to $USD? (3)\n            - What is the SMA for $TSLA? (4)\n\n            Your program should be able to classify all of these queries accurately and output only the number that is associated with the relevant category. Good luck!\n\n            Query: ${query}\n            `,\n      max_tokens: 128,\n      temperature: 0.5\n    });\n    const firstDigit = response.data.choices[0].text.replace(/\\D/g, '')[0];\n    const requestType = parseInt(firstDigit);\n    return requestType;\n  }\n  // STEP 3 \n  async function getSubRequestType(requestType, query) {\n    if (requestType === 1) {\n      try {\n        let requestOne;\n        requestOne = await openai.createCompletion({\n          model: \"text-davinci-003\",\n          prompt: `\n                    Instructions: View the query, and determine the subRequestType, which is the option that most closely matches the query. \n                    Return: The item in the parenthesis that corresponds to the subRequestType.\n                    1. Intraday (TIME_SERIES_INTRADAY)\n                    2. Daily (TIME_SERIES_DAILY)\n                    3. Weekly (TIME_SERIES_WEEKLY)\n                    4. Monthly (TIME_SERIES_MONTHLY)\n                    5. Current Price (GLOBAL_QUOTE)\n            \n                    Query: ${query}\n                    `,\n          max_tokens: 128,\n          temperature: 0.5\n        });\n        console.log(\"requestOne:\", requestOne);\n        return requestOne.data.choices[0].text;\n      } catch (error) {\n        console.error(\"Error in createCompletion function:\", error);\n      }\n    } else if (requestType === 2) {\n      console.log(\"Case Two! Running now...\");\n      let requestFour;\n      requestFour = await openai.createCompletion({\n        model: \"text-davinci-003\",\n        prompt: `\n            Instructions: View the query, and determine the subRequestType, which is the option that most closely matches the query.\n            Return: The item in the parenthesis that corresponds to the subRequestType.\n            1. Exchange Rates (CURRENCY_EXCHANGE_RATE)\n            2. Intraday (FX_INTRADAY)\n            3. Daily (FX_DAILY)\n            4. Weekly (FX_WEEKLY)\n            5. Monthly (FX_MONTHLY)\n            \n            Query: ${query}\n            `,\n        max_tokens: 128,\n        temperature: 0.5\n      });\n      return requestFour.data.choices[0].text;\n    } else if (requestType === 3) {\n      console.log(\"Case Three! Running now...\");\n      let requestFive;\n      requestFive = await openai.createCompletion({\n        model: \"text-davinci-003\",\n        prompt: `\n            Instructions: View the query, and determine the subRequestType, which is the option that most closely matches the query.\n            Return: The item in the parenthesis that corresponds to the subRequestType.\n            1. Exhange Rates (CURRENCY_EXCHANGE_RATE)\n            \n            Query: ${query}\n            `,\n        max_tokens: 128,\n        temperature: 0.5\n      });\n      return requestFive.data.choices[0].text;\n    } else if (requestType === 4) {\n      console.log(\"Case Four! Running now...\");\n      let requestEight;\n      requestEight = await openai.createCompletion({\n        model: \"text-davinci-003\",\n        prompt: `\n            Instructions: View the query, and determine the subRequestType, which is the option that most closely matches the query.\n            Return: The item in the parenthesis that corresponds to the subRequestType.\n            1. SMA (SMA)\n            2. EMA (EMA)\n            3. WMA (WMA)\n            4. DEMA (DEMA)\n            5. TEMA (TEMA)\n            6. TRIMA (TRIMA)\n            7. KAMA (KAMA)\n            8. MAMA (MAMA)\n            9. T3 (T3)\n            10. MACD (MACD)\n            11. MACDEXT (MACDEXT)\n            12. STOCH (STOCH)\n            13. STOCHF (STOCHF)\n            14. RSI (RSI)\n            15. STOCHRSI (STOCHRSI)\n            16. WILLR (WILLR)\n            17. ADX (ADX)\n            18. ADXR (ADXR)\n            19. APO (APO)\n            20. PPO (PPO)\n            21. MOM (MOM)\n            22. BOP (BOP)\n            23. CCI (CCI)\n            24. CMO (CMO)\n            25. ROC (ROC)\n            26. ROCR (ROCR)\n            27. AROON (AROON)\n            28. AROONOSC (AROONOSC)\n            29. MFI (MFI)\n            30. TRIX (TRIX)\n            31. ULTOSC (ULTOSC)\n            32. DX (DX)\n            33. MINUS_DI (MINUS_DI)\n            34. PLUS_DI (PLUS_DI)\n            35. MINUS_DM (MINUS_DM)\n            36. PLUS_DM (PLUS_DM)\n            37. BBANDS (BBANDS)\n            38. MIDPOINT (MIDPOINT)\n            39. MIDPRICE (MIDPRICE)\n            40. SAR (SAR)\n            41. TRANGE (TRANGE)\n            42. ATR (ATR)\n            43. NATR (NATR)\n            44. AD (AD)\n            45. ADOSC (ADOSC)\n            46. OBV (OBV)\n            47. HT_TRENDLINE (HT_TRENDLINE)\n            48. HT_SINE (HT_SINE)\n            49. HT_TRENDMODE (HT_TRENDMODE)\n            50. HT_DCPERIOD (HT_DCPERIOD)\n            51. HT_DCPHASE (HT_DCPHASE)\n            52. HT_PHASOR (HT_PHASOR)\n\n            Query: ${query}\n            `,\n        max_tokens: 128,\n        temperature: 0.5\n      });\n      return requestEight.data.choices[0].text;\n    } else {\n      console.log(\"Invalid Request Type!\");\n    }\n  }\n\n  // STEP 4\n  async function extractInfo(requestType, query, subRequestType) {\n    if (requestType === 1) {\n      // extract stockName, interval \n      try {\n        console.log(\"Extracting stockName & Interval!\");\n        let response;\n        response = await openai.createCompletion({\n          model: \"text-davinci-003\",\n          prompt: `\n                Instructions: View the query, and extract the stock ticker symbol from it. View subRequestType: ${subRequestType}, if it is TIME_SERIES_INTRADAY, extract the interval as well, if no interval, set it to 30min. If it is not TIME_SERIES_INTRADAY, do not extract an interval.\n                Defaults if N/A: symbol: AAPL\n                Return: The output prefaced by the label and a colon. (symbol: AAPL)\n\n                Query: ${query}\n                `,\n          max_tokens: 128,\n          temperature: 0.5\n        });\n        return response.data.choices[0].text;\n      } catch (error) {\n        console.error(error);\n      }\n    } else if (requestType === 2) {\n      // extract fromCurrency, extract toCurrency, if only one currency, make it a USD pair. \n      try {\n        console.log(\"Extracting from_currency, to_currency!\");\n        let response;\n        response = await openai.createCompletion({\n          model: \"text-davinci-003\",\n          prompt: `\n                Instructions: extract the currency pair from this request. If there is only one currency, compare it against USD. view ${subRequestType}, if it is FX_INTRADAY, extract the interval as well, if no interval, set it to 30min.\n                Continued instructions: if the subRequestType is FX_ followed by anything, output the currency pairs as \"from_symbol\" and \"to_symbol\". If the subRequestType is CURRENCY_EXCHANGE_RATE, output the currency pairs as \"from_currency\" and \"to_currency\".\n                Output: from_symbol (unless subRequestType is CURRENCY_EXCHANGE_RATE, then it is from_currency): extracted currency in request, to_symbol(unless subRequestType is CURRENCY_EXCHANGE_RATE, then it is to_currency): extracted currency in request or USD if N/A, interval (if subRequestType is INTRADAY): extracted interval in request or 30min if N/A.\n                Query: ${query}\n                `,\n          max_tokens: 128,\n          temperature: 0.5\n        });\n        return response.data.choices[0].text;\n      } catch (error) {\n        console.error(error);\n      }\n    } else if (requestType === 3) {\n      // extract fromCurrency, extract toCurrency, if only one currency, make it a USD pair. \n      try {\n        console.log(\"Extracting from_currency, to_currency! Crypto Version\");\n        let response;\n        response = await openai.createCompletion({\n          model: \"text-davinci-003\",\n          prompt: `\n                Instructions: extract the currency pair from the Query. If there is only one currency, compare it against USD.\n                Output: from_currency: extracted currency in request, to_currency: extracted currency in request or USD if N/A.\n                Query: ${query}\n                `,\n          max_tokens: 128,\n          temperature: 0.5\n        });\n        return response.data.choices[0].text;\n      } catch (error) {\n        console.error(error);\n      }\n    } else if (requestType === 4) {\n      // extract stockName, extract interval, time_period, series_type\n      try {\n        console.log(\"Extracting stockName, interval, time_period, and series_type!\");\n        let response;\n        response = await openai.createCompletion({\n          model: \"text-davinci-003\",\n          prompt: `\n                Instructions: View the query, and extract the stock ticker symbol from it. Also, extract the time interval, time_period, and series type. (series_type can be close, open, high, low)\n                Defaults if N/a: symbol: AAPL interval: daily, time_period: 200, series_type: open\n                Return: The output prefaced by the label and a colon. (symbol: AAPL, interval: daily, time_period: 60, series_type: open )\n                Query: ${query}\n                `,\n          max_tokens: 128,\n          temperature: 0.5\n        });\n        return response.data.choices[0].text;\n      } catch (error) {\n        console.error(error);\n      }\n    } else {\n      console.log(\"Invalid Request Type\");\n    }\n  }\n  // STEP 5\n  async function formApiParams(subRequestType, extractedInfo) {\n    const response = await openai.createCompletion({\n      model: \"text-davinci-003\",\n      prompt: `\n            Instructions: Take in the function, and the extracted info, and format them like so:\n            \n            function=FUNCTION&extractedInfo1=EXTRACTEDINFO1&extractedInfo2=EXTRACTEDINFO2\n            \n            Example:\n            \n            function: TIME_SERIES_INTRADAY\n            interval is 5min\n            symbol = MSFT\n            \n            function=TIME_SERIES_INTRADAY&interval=5min&symbol=MSFT\n\n            order of organization\n            1. function\n            2. interval (if interval is present)\n            3. everything else\n\n            lowercase operators\n\n            function: ${subRequestType}\n            other info to extract: ${extractedInfo}\n            `,\n      max_tokens: 50,\n      temperature: 0.5\n    });\n    const formattedText = response.data.choices[0].text.trim();\n    const functionIndex = formattedText.indexOf('function=');\n    return formattedText.slice(functionIndex);\n  }\n\n  // STEP 6\n  async function callApi(newApiParams) {\n    const url = `https://alpha-vantage.p.rapidapi.com/query?${newApiParams}&datatype=json&output_size=compact`;\n    const options = {\n      method: 'GET',\n      headers: {\n        'X-RapidAPI-Key': '72afef0eebmsh11f76b0091d62b7p17626bjsnea279a0c36ba',\n        'X-RapidAPI-Host': 'alpha-vantage.p.rapidapi.com'\n      }\n    };\n    const response = await fetch(url, options);\n    const data = await response.text();\n    console.log('Original data:', data);\n    const trimmedData = data.replace(/\\s/g, '').substring(0, 3000);\n    console.log('Trimmed data:', trimmedData);\n    return trimmedData;\n  }\n\n  // STEP 7\n  async function summarizeApiCallData(requestType, subRequestType, apiCallData, query) {\n    const response = await openai.createCompletion({\n      model: \"text-davinci-003\",\n      prompt: `\n                Instructions:\n\n                Summarize the following data in a clear and concise format:\n\n                Data Source: ${requestType}\n                Sub-Request Type: ${subRequestType}\n                Data: ${apiCallData}\n                Answer the following question based on the data:\n\n                ${query}\n\n                Your summary should include the most important insights \n                from the data, presented in a way that is easy to understand. \n                Be sure to include any key statistics or trends that are relevant \n                to the question being asked. Avoid including irrelevant or extraneous \n                information, and focus on presenting the most important data in a way \n                that supports your answer.\n            `,\n      max_tokens: 450,\n      temperature: 0.5\n    });\n    return response.data.choices[0].text;\n  }\n}\n_c = AlphaVantage;\nvar _c;\n$RefreshReg$(_c, \"AlphaVantage\");","map":{"version":3,"names":["Configuration","OpenAIApi","require","orgId","apiKey","configuration","openai","AlphaVantage","query","workflow","console","log","requestType","getRequestType","subRequestType","getSubRequestType","extractedInfo","extractInfo","apiParams","formApiParams","apiCallData","callApi","summarizedApiCallData","summarizeApiCallData","response","createCompletion","model","prompt","max_tokens","temperature","firstDigit","data","choices","text","replace","parseInt","requestOne","error","requestFour","requestFive","requestEight","formattedText","trim","functionIndex","indexOf","slice","newApiParams","url","options","method","headers","fetch","trimmedData","substring"],"sources":["/Users/aaronleek/Desktop/coding-projects/kari-ai/kari-platform/Kari-React-Client/Kari-React-Client/src/Models/APIs/AlphaVantage.js"],"sourcesContent":["/**\n * AlphaVantage takes in a query, determines the request type, determines the subRequestType, extracts\n * the necessary information, forms the apiParams, calls the api, and summarizes the apiCallData\n * @param query - the query that the user is asking\n */\n\nconst { Configuration, OpenAIApi } = require('openai');\n\n\n// to do: move these to env variables\n// 2. Make summary better\n\n\nconst orgId = \"org-rnY9Z2LuVmBnRlAsfLipqzcf\";\nconst apiKey = \"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\";\n\nconst configuration = new Configuration({\n    orgId: orgId,\n    apiKey: apiKey,\n});\nconst openai = new OpenAIApi(configuration);\n\nexport async function AlphaVantage(query) {\n\n    async function workflow(query) {\n        console.log(\"AV-1: extracting requestType\")\n        const requestType = await getRequestType(query); // STEP 1\n        console.log(\"AV-3: extracting subRequestType from requestType:\", requestType, \"and query:\", query);\n        const subRequestType = await getSubRequestType(requestType, query); // STEP 3\n        console.log(\"AV: Step 4: extractingInfo from requestType & Query:\", requestType, query);\n        const extractedInfo = await extractInfo(requestType, query); // STEP 4\n        console.log(\"AV: Step 5: formingApiParams from extractedInfo and subRequestType:\", extractedInfo, subRequestType);\n        const apiParams = await formApiParams(subRequestType, extractedInfo) // STEP 5\n        console.log(\"AV: Making API Call with params:\", apiParams)\n        const apiCallData = await callApi(apiParams); // STEP 6\n        console.log(\"AV: Step 7: summarizingApiCallData with current date, requestType, subrequestType, apiCallData, and query:\", requestType, subRequestType, apiCallData, query)\n        const summarizedApiCallData = await summarizeApiCallData(requestType, subRequestType, apiCallData, query); // STEP 7\n        console.log(\"AV: Final Step: Return Summary\", summarizedApiCallData);\n        return summarizedApiCallData;\n    }\n    const response = await workflow(query);\n    return response;\n    // STEP 1\n    async function getRequestType(query) {\n        const response = await openai.createCompletion({\n            model: \"text-davinci-003\",\n            prompt: `\n\n           Your task is to classify a given query into one of the following four categories:\n\n            1. Core Stock APIS - Intraday, Daily, Weekly, Monthly, & Current Price (just stock prices)\n            2. Forex - Fiat Exchange Rates, Intraday, Daily, Weekly, Monthly (just exchange rates)\n            3. Cryptocurrency - Crypto Exchange Rates, Intraday, Daily, Weekly, Monthly (just exchange rates, but for crypto)\n            4. Technical Indicators - SMA, EMA, WMA, DEMA, TEMA, TRIMA, KAMA, MAMA, T3, MACD, MACDEXT, STOCH, STOCHF, RSI, STOCHRSI, WILLR, ADX, ADXR, APO, PPO, MOM, BOP, CCI, CMO, ROC, ROCR, AROON, AROONOSC, MFI, TRIX, ULTOSC, DX, MINUS_DI, PLUS_DI, MINUS_DM, PLUS_DM, BBANDS, MIDPOINT, MIDPRICE, SAR, TRANGE, ATR, NATR, AD, ADOSC, OBV, HT_TRENDLINE, HT_SINE, HT_TRENDMODE, HT_DCPERIOD, HT_DCPHASE, HT_PHASOR (technical indicators)\n\n            Your program should be able to determine the request type based on the given query and output only the number that is associated with the relevant category.\n\n            Here are some examples of the types of questions your program should be able to classify:\n\n            - What is the current price of $TSLA? (1)\n            - What are intraday prices for $TSLA? (1)\n            - What are daily prices for $TSLA? (1)\n            - What are weekly prices for $TSLA? (1)\n            - What are monthly prices for $TSLA? (1)\n            - What is the current exchange rate for $USD to $CAD? (2)\n            - What is the intraday exchange rate for $USD to $CAD? (2)\n            - What are daily exchange rates for $USD to $CAD? (2)\n            - What are weekly exchange rates for $USD to $CAD? (2)\n            - What are monthly exchange rates for $USD to $CAD? (2)\n            - What is the current exchange rate for $BTC to $USD? (3)\n            - What is the SMA for $TSLA? (4)\n\n            Your program should be able to classify all of these queries accurately and output only the number that is associated with the relevant category. Good luck!\n\n            Query: ${query}\n            `,\n            max_tokens: 128,\n            temperature: 0.5,\n\n        })\n        const firstDigit = response.data.choices[0].text.replace(/\\D/g, '')[0];\n        const requestType = parseInt(firstDigit);\n        return requestType;\n    }\n    // STEP 3 \n    async function getSubRequestType(requestType, query) {\n        if (requestType === 1) {\n            try {\n                let requestOne;\n                requestOne = await openai.createCompletion({\n                    model: \"text-davinci-003\",\n                    prompt: `\n                    Instructions: View the query, and determine the subRequestType, which is the option that most closely matches the query. \n                    Return: The item in the parenthesis that corresponds to the subRequestType.\n                    1. Intraday (TIME_SERIES_INTRADAY)\n                    2. Daily (TIME_SERIES_DAILY)\n                    3. Weekly (TIME_SERIES_WEEKLY)\n                    4. Monthly (TIME_SERIES_MONTHLY)\n                    5. Current Price (GLOBAL_QUOTE)\n            \n                    Query: ${query}\n                    `,\n                    max_tokens: 128,\n                    temperature: 0.5,\n                });\n                console.log(\"requestOne:\", requestOne);\n                return requestOne.data.choices[0].text;\n            } catch (error) {\n                console.error(\"Error in createCompletion function:\", error);\n            }\n        } else if (requestType === 2) {\n            console.log(\"Case Two! Running now...\");\n            let requestFour;\n            requestFour = await openai.createCompletion({\n                model: \"text-davinci-003\",\n                prompt: `\n            Instructions: View the query, and determine the subRequestType, which is the option that most closely matches the query.\n            Return: The item in the parenthesis that corresponds to the subRequestType.\n            1. Exchange Rates (CURRENCY_EXCHANGE_RATE)\n            2. Intraday (FX_INTRADAY)\n            3. Daily (FX_DAILY)\n            4. Weekly (FX_WEEKLY)\n            5. Monthly (FX_MONTHLY)\n            \n            Query: ${query}\n            `,\n                max_tokens: 128,\n                temperature: 0.5,\n            })\n            return requestFour.data.choices[0].text;\n        } else if (requestType === 3) {\n            console.log(\"Case Three! Running now...\");\n            let requestFive;\n            requestFive = await openai.createCompletion({\n                model: \"text-davinci-003\",\n                prompt: `\n            Instructions: View the query, and determine the subRequestType, which is the option that most closely matches the query.\n            Return: The item in the parenthesis that corresponds to the subRequestType.\n            1. Exhange Rates (CURRENCY_EXCHANGE_RATE)\n            \n            Query: ${query}\n            `,\n                max_tokens: 128,\n                temperature: 0.5,\n            })\n            return requestFive.data.choices[0].text;\n        } else if (requestType === 4) {\n            console.log(\"Case Four! Running now...\");\n            let requestEight;\n            requestEight = await openai.createCompletion({\n                model: \"text-davinci-003\",\n                prompt: `\n            Instructions: View the query, and determine the subRequestType, which is the option that most closely matches the query.\n            Return: The item in the parenthesis that corresponds to the subRequestType.\n            1. SMA (SMA)\n            2. EMA (EMA)\n            3. WMA (WMA)\n            4. DEMA (DEMA)\n            5. TEMA (TEMA)\n            6. TRIMA (TRIMA)\n            7. KAMA (KAMA)\n            8. MAMA (MAMA)\n            9. T3 (T3)\n            10. MACD (MACD)\n            11. MACDEXT (MACDEXT)\n            12. STOCH (STOCH)\n            13. STOCHF (STOCHF)\n            14. RSI (RSI)\n            15. STOCHRSI (STOCHRSI)\n            16. WILLR (WILLR)\n            17. ADX (ADX)\n            18. ADXR (ADXR)\n            19. APO (APO)\n            20. PPO (PPO)\n            21. MOM (MOM)\n            22. BOP (BOP)\n            23. CCI (CCI)\n            24. CMO (CMO)\n            25. ROC (ROC)\n            26. ROCR (ROCR)\n            27. AROON (AROON)\n            28. AROONOSC (AROONOSC)\n            29. MFI (MFI)\n            30. TRIX (TRIX)\n            31. ULTOSC (ULTOSC)\n            32. DX (DX)\n            33. MINUS_DI (MINUS_DI)\n            34. PLUS_DI (PLUS_DI)\n            35. MINUS_DM (MINUS_DM)\n            36. PLUS_DM (PLUS_DM)\n            37. BBANDS (BBANDS)\n            38. MIDPOINT (MIDPOINT)\n            39. MIDPRICE (MIDPRICE)\n            40. SAR (SAR)\n            41. TRANGE (TRANGE)\n            42. ATR (ATR)\n            43. NATR (NATR)\n            44. AD (AD)\n            45. ADOSC (ADOSC)\n            46. OBV (OBV)\n            47. HT_TRENDLINE (HT_TRENDLINE)\n            48. HT_SINE (HT_SINE)\n            49. HT_TRENDMODE (HT_TRENDMODE)\n            50. HT_DCPERIOD (HT_DCPERIOD)\n            51. HT_DCPHASE (HT_DCPHASE)\n            52. HT_PHASOR (HT_PHASOR)\n\n            Query: ${query}\n            `,\n                max_tokens: 128,\n                temperature: 0.5,\n            })\n            return requestEight.data.choices[0].text;\n        } else {\n            console.log(\"Invalid Request Type!\")\n        }\n    }\n\n    // STEP 4\n    async function extractInfo(requestType, query, subRequestType) {\n        if (requestType === 1) { // extract stockName, interval \n            try {\n                console.log(\"Extracting stockName & Interval!\")\n                let response;\n                response = await openai.createCompletion({\n                    model: \"text-davinci-003\",\n                    prompt: `\n                Instructions: View the query, and extract the stock ticker symbol from it. View subRequestType: ${subRequestType}, if it is TIME_SERIES_INTRADAY, extract the interval as well, if no interval, set it to 30min. If it is not TIME_SERIES_INTRADAY, do not extract an interval.\n                Defaults if N/A: symbol: AAPL\n                Return: The output prefaced by the label and a colon. (symbol: AAPL)\n\n                Query: ${query}\n                `,\n                    max_tokens: 128,\n                    temperature: 0.5\n                })\n                return response.data.choices[0].text;\n            } catch (error) {\n                console.error(error);\n            }\n        } else if (requestType === 2) { // extract fromCurrency, extract toCurrency, if only one currency, make it a USD pair. \n            try {\n                console.log(\"Extracting from_currency, to_currency!\");\n                let response;\n                response = await openai.createCompletion({\n                    model: \"text-davinci-003\",\n                    prompt: `\n                Instructions: extract the currency pair from this request. If there is only one currency, compare it against USD. view ${subRequestType}, if it is FX_INTRADAY, extract the interval as well, if no interval, set it to 30min.\n                Continued instructions: if the subRequestType is FX_ followed by anything, output the currency pairs as \"from_symbol\" and \"to_symbol\". If the subRequestType is CURRENCY_EXCHANGE_RATE, output the currency pairs as \"from_currency\" and \"to_currency\".\n                Output: from_symbol (unless subRequestType is CURRENCY_EXCHANGE_RATE, then it is from_currency): extracted currency in request, to_symbol(unless subRequestType is CURRENCY_EXCHANGE_RATE, then it is to_currency): extracted currency in request or USD if N/A, interval (if subRequestType is INTRADAY): extracted interval in request or 30min if N/A.\n                Query: ${query}\n                `,\n                    max_tokens: 128,\n                    temperature: 0.5\n                })\n                return response.data.choices[0].text;\n            } catch (error) {\n                console.error(error);\n            }\n        } else if (requestType === 3) { // extract fromCurrency, extract toCurrency, if only one currency, make it a USD pair. \n            try {\n                console.log(\"Extracting from_currency, to_currency! Crypto Version\");\n                let response;\n                response = await openai.createCompletion({\n                    model: \"text-davinci-003\",\n                    prompt: `\n                Instructions: extract the currency pair from the Query. If there is only one currency, compare it against USD.\n                Output: from_currency: extracted currency in request, to_currency: extracted currency in request or USD if N/A.\n                Query: ${query}\n                `,\n                    max_tokens: 128,\n                    temperature: 0.5\n                })\n                return response.data.choices[0].text;\n            } catch (error) {\n                console.error(error);\n            }\n        } else if (requestType === 4) { // extract stockName, extract interval, time_period, series_type\n            try {\n                console.log(\"Extracting stockName, interval, time_period, and series_type!\");\n                let response;\n                response = await openai.createCompletion({\n                    model: \"text-davinci-003\",\n                    prompt: `\n                Instructions: View the query, and extract the stock ticker symbol from it. Also, extract the time interval, time_period, and series type. (series_type can be close, open, high, low)\n                Defaults if N/a: symbol: AAPL interval: daily, time_period: 200, series_type: open\n                Return: The output prefaced by the label and a colon. (symbol: AAPL, interval: daily, time_period: 60, series_type: open )\n                Query: ${query}\n                `,\n                    max_tokens: 128,\n                    temperature: 0.5\n                })\n                return response.data.choices[0].text;\n            } catch (error) {\n                console.error(error);\n            }\n        } else {\n            console.log(\"Invalid Request Type\");\n        }\n    }\n    // STEP 5\n    async function formApiParams(subRequestType, extractedInfo) {\n        const response = await openai.createCompletion({\n            model: \"text-davinci-003\",\n            prompt: `\n            Instructions: Take in the function, and the extracted info, and format them like so:\n            \n            function=FUNCTION&extractedInfo1=EXTRACTEDINFO1&extractedInfo2=EXTRACTEDINFO2\n            \n            Example:\n            \n            function: TIME_SERIES_INTRADAY\n            interval is 5min\n            symbol = MSFT\n            \n            function=TIME_SERIES_INTRADAY&interval=5min&symbol=MSFT\n\n            order of organization\n            1. function\n            2. interval (if interval is present)\n            3. everything else\n\n            lowercase operators\n\n            function: ${subRequestType}\n            other info to extract: ${extractedInfo}\n            `,\n            max_tokens: 50,\n            temperature: 0.5,\n        })\n        const formattedText = response.data.choices[0].text.trim();\n        const functionIndex = formattedText.indexOf('function=');\n        return formattedText.slice(functionIndex);\n    }\n\n    // STEP 6\n    async function callApi(newApiParams) {\n        const url = `https://alpha-vantage.p.rapidapi.com/query?${newApiParams}&datatype=json&output_size=compact`;\n        const options = {\n            method: 'GET',\n            headers: {\n                'X-RapidAPI-Key': '72afef0eebmsh11f76b0091d62b7p17626bjsnea279a0c36ba',\n                'X-RapidAPI-Host': 'alpha-vantage.p.rapidapi.com'\n            }\n        };\n        const response = await fetch(url, options);\n        const data = await response.text();\n        console.log('Original data:', data);\n        const trimmedData = data.replace(/\\s/g, '').substring(0, 3000);\n        console.log('Trimmed data:', trimmedData);\n        return trimmedData;\n    }\n\n\n    // STEP 7\n    async function summarizeApiCallData(requestType, subRequestType, apiCallData, query) {\n        const response = await openai.createCompletion({\n            model: \"text-davinci-003\",\n            prompt: `\n                Instructions:\n\n                Summarize the following data in a clear and concise format:\n\n                Data Source: ${requestType}\n                Sub-Request Type: ${subRequestType}\n                Data: ${apiCallData}\n                Answer the following question based on the data:\n\n                ${query}\n\n                Your summary should include the most important insights \n                from the data, presented in a way that is easy to understand. \n                Be sure to include any key statistics or trends that are relevant \n                to the question being asked. Avoid including irrelevant or extraneous \n                information, and focus on presenting the most important data in a way \n                that supports your answer.\n            `,\n            max_tokens: 450,\n            temperature: 0.5\n\n        })\n        return response.data.choices[0].text;\n    }\n\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}